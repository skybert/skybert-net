<!--#include virtual="/ssi/header.shtml" -->
    <h1>Enterprise Java Development in Emacs</h1>
    <div id="main">
      <div style="float: right">
        <img src="../graphics/emacs.png" alt="png"/>
      </div>
      <h2>Code completion</h2>
      <p>
        This is my favourite feature of <a href="">emacs-eclim</a>,
        the ability to get real, 100% correct auto completion of
        everything, without clever hacks like
        <code>hippe-expand</code> and vanilla
        <code>auto-complete-mode</code>:
      </p>
      <img src="eclim-code-completion.png" alt="code completion"/>
      <h2>On the fly syntax checking</h2>
      <p>
        Since very few of us can remember all the nuts and bolts of
        the vast Java class library, not to mention all the brilliant
        and esoteric 3rd party APIs out there, Emacs offers just the
        thing we need: on the fly syntax checking. It will underline
        plain compilation errors in red, whereas Java warnings will be
        underlined with yellow marker:
      </p>
      <img src="eclim-java-warning.png" alt="eclim java warning"/>
      <h2>Jump to source</h2>
      <p>
        When navigating huge source trees, this feature is
        indispensable (even though things like <code>file-cache</code>
        and <code>find-dired</code> provide decent generalised file
        lookups):
      </p>
      <img src="eclim-jump-to-source-before.png"
           alt="jump to source before jumping"/>
      <p>
        When invoking <code>eclim-java-find-declaration</code>, you're
        instantly taken to the class in question (here open in a new
        buffer):
      </p>
      <img src="eclim-jump-to-source-after.png"
           alt="jump to source after jump"/>
      <h2>Showing all references</h2>
      <p>
        It's often useful to see all references to a given method or
        class. Put your point at the class name or method in question
        and call the command <code>eclim-java-find-references</code>:
      </p>
      <img src="eclim-find-references.png" alt="find references"/>
      <h2>Refactoring</h2>
      <p>
        Java developers love refactoring, especially changing the name
        of variables and methods is something many of us do all the
        time. Emacs will happily do all of the work for you if you
        just navigate to the method, class or variable in question
        invoke
        <code>eclim-java-refactor-rename-symbol-at-point</code>:
      </p>
      <img src="eclim-refactoring-before.png" alt="refactoring before"/>
      <p>
        Emacs will then make all the required changes in all files in
        the project:
      </p>
      <img src="eclim-refactoring-after.png" alt="refactoring after"/>
      <h2>Getting help wherever you are</h2>
      <p>
        Put your pointer on the class or method you want and call
        <code>eclim-java-show-documentation-for-current-element</code>:
      </p>
      <img src="eclim-show-javadoc.png" alt="show javadoc"/>
      <h2>Showing class inheritance</h2>
      <p>
        Emacs will quite happily show you a class' or an interface's
        inheritance hiearchy if you invoke
        <code>eclim-java-hierarchy</code>:
      </p>
      <img src="eclim-show-class-inheritance.png" alt="show inheritance"/>
      <h2>Importing classes &amp; organising imports</h2>
      <p>
        Emacs will import any missing classes and re-organising the
        imports while it's at it when you call
        <code>eclim-java-import-organize</code>:
      </p>
      <img src="eclim-import-before.png"
           alt="before importing missing classes"
           />
      <p>
        For the most part, this will work without an itch, the
        exception being ambiguities like <code>java.util.List</code>
        and <code>java.awt.List</code>:
      </p>
      <img src="eclim-import-after.png"
           alt="after importing missing classes"
           />
      <h2>Correcting problems</h2>
      <p>
        A feature which makes Java IDEs so appealing is that they
        suggest fixes to various problems in your code. In fact, this feature
        has gotten so good, many Java developers rely on it as a way
        of programming. Instead of creating methods and variables
        before using them, they instead rely on the IDE to create them
        as they refer to new methods or field members.
      </p>
      <p>
        Many will be very surprised to find that Emacs now also has
        this feature, here's an example where the code refers to a
        not yet written method:
      </p>
      <img src="eclim-correct-problem-method-doesnt-exist.png"
           alt="referring to non existent method"
           />
      <p>
        Invoking <code>eclim-problems-correct</code> opens up another
        buffer in which you may preview the different suggestions and
        before applying them with the suggested fix's number
        (<code>0-9</code>):
      </p>
      <img src="eclim-correct-problem.png"
           alt="eclim problems correct"
           />
      <p>
        After hitting <code>0</code>, the method is added to the
        correct class:
      </p>
      <img src="eclim-correct-problem-success.png"
           alt="problem corrected"
           />
      <h2>Maven integration</h2>
      <p>
        Using the excellent <a
        href="http://www.thaiopensource.com/nxml-mode/">nxml-mode</a>,
        Emacs gives you both on the fly syntax checking (or XML
        validation if you will) and auto completion when editing your
        POM files:
      </p>
      <img src="nxml-maven-pom-auto-completion-and-syntax-checking.png"
           alt="Using nxml mode for editing POMs"
          />
      <p>
        Wherever you are in your Java project, you can always invoke
        <code>eclim-maven-run</code> to run any of the Maven
        goals. Any errors, be that compilation or unit test failure,
        can be clicked on for instant viewing of the offending code in
        the editor:
      </p>
      <img src="eclim-run-maven.png" alt="eclim run maven"/>
      <h2>Source control</h2>
      <p>
        The source code control integration in Emacs is second to
        none. It's extremely fast and supports just about all systems
        out of the box.
      </p>
      <p>
        You don't have to worry about which backend you're using,
        Emacs will let you do all the checkins, checkouts,
        annotations, diff-ing and so on using the same commands,
        regardless if you're using CVS, Subversion, Perforce, Git or
        Mercurial.
      </p>
      <p>
        Here, I'm viewing the commit log (by running
        <code>vc-print-log</code>) for one Java class while viewing
        the diff (by hitting <code>d</code> when navigating the
        commits with <code>n</code> and <code>p</code>) of one of the
        commits in the bottom buffer.
      </p>
      <img src="vc-git-log-and-diff.png"
           alt="version control in Emacs"/>
      <h2>Editing popular Java world XML files</h2>
      <p>
        Emacs and <code>nxml-mode</code> will give you on the fly
        syntax checking and auto completion for all popular XML file
        formats in the Java world. I've enjoyed error free editing of
        iBATIS, Struts, DWR, Spring, Tomcat, Resin, Escenic Ant &amp;
        Maven XML files using <a
        href="https://github.com/skybert/my-little-friends/tree/master/emacs/.emacs.d/xml">these
        Relax NG RNC files</a> with <code>nxml-mode</code>
      </p>
      <h2>
        <a name="installation">Installation</a>
      </h2>
      <p>
        To get the code completion, code navigation, javadoc lookup
        and so on working, we need to set up this call flow:
      </p>
      <img src="emacs-eclim-eclipse.svg"
           alt="emacs to eclim to eclipse call flow"
           />
      <h3>Eclipse</h3>
      <p>
        First things first, you need to get <a
        href="http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/junosr1">Eclipse
        IDE for Java Developers</a>, at the time of writing
        (2012-12-01), I'm using the version called Juno SR1, or
        <code>4.2.1</code>, which I put in
        <code>/opt/eclipse-4.2.1</code> with a symlink
        <code>/opt/eclipse</code> pointing to it:
      </p>
      <pre>$ ls /opt/eclipse
lrwxrwxrwx 1 root root 14 Sep 29 00:57 /opt/eclipse -> eclipse-4.2.1</pre>
      <p>
        We're not quite done with Eclipse yet as it doesn't have
        proper support for Maven out of the box. We're now in 2012,
        but Maven is still no first class citizen in Eclipse. If
        someone can explain why, I'd be interested in listening. Be
        that as it may, while we're in set up mode, install the <a
        href="http://eclipse.org/m2e">m2e plugin</a> for Eclipse. This
        makes Eclipse treat Maven more or less in the same way as the
        ubiquitous Intellij IDEA.
      </p>
      <h3>eclim</h3>
      <p>
        Next stop is the excellent "Eclipse to Any Editor" bridge
        called <a href="http://eclim.org">eclim</a> (its first class citizen
        is Vim, but we can use it for Emacs too). It lets us get all
        the goodness of Eclipse (code completion, refactoring, syntax
        checking++) in our beloved editor with no extra configuration,
        hacks or fuss.
      </p>
      <p>
        I install all 3rd party sources in <code>/usr/local/src</code>
        to differ them from my own sources in <code>~/src</code>,
        thus:
      </p>
      <pre>$ cd /usr/local/src
$ git clone git://github.com/ervandew/eclim.git
$ cd eclim
$ ant clean deploy -Declipse.home=/opt/eclipse
</pre>
      <p>
        This will install the <code>eclim</code> plugin in our
        <code>/opt/eclipse</code> directory, with symlinks to the two
        eclim binaries in the root (that looks a bit messy, doesn't
        it? Oh well, the important thing is that it works :-)):
      </p>
      <pre>$ ls /opt/eclipse/eclim*
lrwxrwxrwx 1 torstein 8779 44 Dec  1 11:40 /opt/eclipse/eclim -> plugins/org.eclim_2.2.5.3-gaad35e4/bin/eclim
lrwxrwxrwx 1 torstein 8779 45 Dec  1 11:40 /opt/eclipse/eclimd -> plugins/org.eclim_2.2.5.3-gaad35e4/bin/eclimd</pre>
      <p>
        If you like me, prefer launching <code>eclimd</code> from a
        dedicated shell, be sure to set up your workspace directory in
        <code>.eclimrc</code> if it's different from
        <code>~/worskpace</code>. Here you can also assign more memory
        to <code>eclimd</code>:
      </p>
      <pre># workspace dir
osgi.instance.area.default=@user.home/src/workspace

# increase heap size
-Xmx256M

# increase perm gen size
-XX:PermSize=64m
-XX:MaxPermSize=128m</pre>
      <p>
        If you're using a non default location for your workspace and
        you don't set the workspace directory here, you'll probably
        get confused as to when <code>eclim</code> does and does not
        find your projects. I for sure was!
      </p>
      <h3>emacs-eclim</h3>
      <p>
        The last piece of the puzzle, is the excellent Emacs eclim
        library which acts as a bridge between Emacs and the
        <code>eclimd</code> process.
      </p>
      <p>
        At the time of writing (2012-12-01), there's no Emacs package
        of <code>emacs-eclim</code>, hence, I put it with my other
        Emacs modules that are neither installed with APT nor with
        Emacs packages in <code>/usr/local/src/emacs</code>. Hence:
      </p>
      <pre>$ cd /usr/local/src/emacs
$ git clone https://github.com/senny/emacs-eclim.git</pre>
      <p>
        Finally, there's some Lisp to set it all up. I've put this in
        my <a
        href="https://github.com/skybert/my-little-friends/blob/master/emacs/.emacs.d/tkj-eclim.el">
        ~/.emacs.d/tkj-eclim.el </a>, but you can of course put it
        anywhere you like, like <code>~/.emacs</code> :-)
      </p>
    </div>
<!--#include virtual="/ssi/footer.shtml" -->
